<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Monoidal_Categories">
<Heading>Monoidal Categories</Heading>

<P/>
<Section Label="Chapter_Monoidal_Categories_Section_Monoidal_Categories">
<Heading>Monoidal Categories</Heading>

<P/>
A <Math>6</Math>-tuple <Math>( \mathbf{C}, \otimes, 1, \alpha, \lambda, \rho )</Math>
 consisting of
<List>
<Item>
a category <Math>\mathbf{C}</Math>,
</Item>
<Item>
a functor <Math>\otimes: \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}</Math> compatible with the congruence of morphisms,
</Item>
<Item>
an object <Math>1 \in \mathbf{C}</Math>,
</Item>
<Item>
a natural isomorphism <Math>\alpha_{a,b,c}: a \otimes (b \otimes c) \cong (a \otimes b) \otimes c</Math>,
</Item>
<Item>
a natural isomorphism <Math>\lambda_{a}: 1 \otimes a \cong a</Math>,
</Item>
<Item>
a natural isomorphism <Math>\rho_{a}: a \otimes 1 \cong a</Math>,
</Item>
</List>
is called a <Emph>monoidal category</Emph>, if
<List>
<Item>
for all objects <Math>a,b,c,d</Math>, the pentagon identity holds:
</Item>
</List>
 <Math>(\alpha_{a,b,c} \otimes \mathrm{id}_d) \circ \alpha_{a,b \otimes c, d} \circ ( \mathrm{id}_a \otimes \alpha_{b,c,d} ) \sim \alpha_{a \otimes b, c, d} \circ \alpha_{a,b,c \otimes d}</Math>,
<List>
<Item>
for all objects <Math>a,c</Math>, the triangle identity holds:
</Item>
</List>
 <Math>( \rho_a \otimes \mathrm{id}_c ) \circ \alpha_{a,1,c} \sim \mathrm{id}_a \otimes \lambda_c</Math>.
<P/>
The corresponding GAP property is given by
<C>IsMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="alpha, beta" Name="TensorProductOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, a' \otimes b')</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the tensor product <Math>\alpha \otimes \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="TensorProductOnMorphismsWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, a' \otimes b')</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes b</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = a' \otimes b'</Math>.
 The output is the tensor product <Math>\alpha \otimes \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="AssociatorRightToLeft" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b \otimes c), (a \otimes b) \otimes c )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the associator <Math>\alpha_{a,(b,c)}: a \otimes (b \otimes c) \rightarrow (a \otimes b) \otimes c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="AssociatorRightToLeftWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b \otimes c), (a \otimes b) \otimes c )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes (b \otimes c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = (a \otimes b) \otimes c</Math>.
 The output is the associator <Math>\alpha_{a,(b,c)}: a \otimes (b \otimes c) \rightarrow (a \otimes b) \otimes c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="AssociatorLeftToRight" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the associator <Math>\alpha_{(a,b),c}: (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="AssociatorLeftToRightWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c) )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b) \otimes c</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = a \otimes (b \otimes c)</Math>.
 The output is the associator <Math>\alpha_{(a,b),c}: (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftUnitor" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1 \otimes a, a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the left unitor <Math>\lambda_a: 1 \otimes a \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="LeftUnitorWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1 \otimes a, a)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>s = 1 \otimes a</Math>.
 The output is the left unitor <Math>\lambda_a: 1 \otimes a \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftUnitorInverse" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, 1 \otimes a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the left unitor <Math>\lambda_a^{-1}: a \rightarrow 1 \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="LeftUnitorInverseWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, 1 \otimes a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math> and an object <Math>r = 1 \otimes a</Math>.
 The output is the inverse of the left unitor <Math>\lambda_a^{-1}: a \rightarrow 1 \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RightUnitor" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes 1, a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the right unitor <Math>\rho_a: a \otimes 1 \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="RightUnitorWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes 1, a)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>s = a \otimes 1</Math>.
 The output is the right unitor <Math>\rho_a: a \otimes 1 \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RightUnitorInverse" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, a \otimes 1)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the right unitor <Math>\rho_a^{-1}: a \rightarrow a \otimes 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="RightUnitorInverseWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, a \otimes 1)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>r = a \otimes 1</Math>.
 The output is the inverse of the right unitor <Math>\rho_a^{-1}: a \rightarrow a \otimes 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="TensorProductOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the tensor product <Math>a \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="C" Name="TensorUnit" Label="for IsCapCategory"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is a category <Math>\mathbf{C}</Math>.
 The output is the tensor unit <Math>1</Math> of <Math>\mathbf{C}</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Additive_Monoidal_Categories">
<Heading>Additive Monoidal Categories</Heading>

<P/>
<ManSection>
  <Oper Arg="a, L" Name="LeftDistributivityExpanding" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b_1 \oplus \dots \oplus b_n), (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n) )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>
 and a list of objects <Math>L = (b_1, \dots, b_n)</Math>.
 The output is the left distributivity morphism
 <Math>a \otimes (b_1 \oplus \dots \oplus b_n) \rightarrow (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, L, r" Name="LeftDistributivityExpandingWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes (b_1 \oplus \dots \oplus b_n)</Math>,
 an object <Math>a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 and an object <Math>r = (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>.
 The output is the left distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, L" Name="LeftDistributivityFactoring" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n), a \otimes (b_1 \oplus \dots \oplus b_n) )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>
 and a list of objects <Math>L = (b_1, \dots, b_n)</Math>.
 The output is the left distributivity morphism
 <Math>(a \otimes b_1) \oplus \dots \oplus (a \otimes b_n) \rightarrow a \otimes (b_1 \oplus \dots \oplus b_n)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, L, r" Name="LeftDistributivityFactoringWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>,
 an object <Math>a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 and an object <Math>r = a \otimes (b_1 \oplus \dots \oplus b_n)</Math>.
 The output is the left distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L, a" Name="RightDistributivityExpanding" Label="for IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (b_1 \oplus \dots \oplus b_n) \otimes a, (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a) )</Math>
</Returns>
 <Description>
 The arguments are a list of objects <Math>L = (b_1, \dots, b_n)</Math>
 and an object <Math>a</Math>.
 The output is the right distributivity morphism
 <Math>(b_1 \oplus \dots \oplus b_n) \otimes a \rightarrow (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, L, a, r" Name="RightDistributivityExpandingWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (b_1 \oplus \dots \oplus b_n) \otimes a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>.
 The output is the right distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L, a" Name="RightDistributivityFactoring" Label="for IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a), (b_1 \oplus \dots \oplus b_n) \otimes a)</Math>
</Returns>
 <Description>
 The arguments are a list of objects <Math>L = (b_1, \dots, b_n)</Math>
 and an object <Math>a</Math>.
 The output is the right distributivity morphism
 <Math>(b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a) \rightarrow (b_1 \oplus \dots \oplus b_n) \otimes a </Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, L, a, r" Name="RightDistributivityFactoringWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = (b_1 \oplus \dots \oplus b_n) \otimes a</Math>.
 The output is the right distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Braided_Monoidal_Categories">
<Heading>Braided Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math> equipped with a natural isomorphism
<Math>B_{a,b}: a \otimes b \cong b \otimes a</Math>
is called a <Emph>braided monoidal category</Emph>
if
<List>
<Item>
<Math>\lambda_a \circ B_{a,1} \sim \rho_a</Math>,
</Item>
<Item>
<Math>(B_{c,a} \otimes \mathrm{id}_b) \circ \alpha_{c,a,b} \circ B_{a \otimes b,c} \sim \alpha_{a,c,b} \circ ( \mathrm{id}_a \otimes B_{b,c}) \circ \alpha^{-1}_{a,b,c}</Math>,
</Item>
<Item>
<Math>( \mathrm{id}_b \otimes B_{c,a} ) \circ \alpha^{-1}_{b,c,a} \circ B_{a,b \otimes c} \sim \alpha^{-1}_{b,a,c} \circ (B_{a,b} \otimes \mathrm{id}_c) \circ \alpha_{a,b,c}</Math>.
</Item>
</List>
<P/>
The corresponding GAP property is given by
<C>IsBraidedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="Braiding" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes b, b \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the braiding <Math> B_{a,b}: a \otimes b \rightarrow b \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="BraidingWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes b, b \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes b</Math>, 
 two objects <Math>a,b</Math>,
 and an object <Math>r = b \otimes a</Math>.
 The output is the braiding <Math> B_{a,b}: a \otimes b \rightarrow b \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="BraidingInverse" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b \otimes a, a \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse braiding <Math> B_{a,b}^{-1}: b \otimes a \rightarrow a \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="BraidingInverseWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b \otimes a, a \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = b \otimes a</Math>, 
 two objects <Math>a,b</Math>,
 and an object <Math>r = a \otimes b</Math>.
 The output is the inverse braiding <Math> B_{a,b}^{-1}: b \otimes a \rightarrow a \otimes b</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Monoidal_Categories">
<Heading>Symmetric Monoidal Categories</Heading>

<P/>
A braided monoidal category <Math>\mathbf{C}</Math> is called <Emph>symmetric monoidal category</Emph>
if <Math>B_{a,b}^{-1} \sim B_{b,a}</Math>.
The corresponding GAP property is given by
<C>IsSymmetricMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Left_Closed_Monoidal_Categories">
<Heading>Left Closed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a right adjoint (denoted by <Math>\mathrm{\underline{Hom}_\ell}(b,-)</Math>)
is called a <Emph>left closed monoidal category</Emph>.
<P/>
If no operations involving left duals are installed manually, the left dual objects will be derived as <Math>a^\vee \coloneqq \mathrm{\underline{Hom}_\ell}(a,1)</Math>.
<P/>
The corresponding GAP property is called
<C>IsLeftClosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="LeftInternalHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal hom object <Math>\mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="LeftInternalHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}_\ell}(a',b), \mathrm{\underline{Hom}_\ell}(a,b') )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}_\ell}(\alpha,\beta): \mathrm{\underline{Hom}_\ell}(a',b) \rightarrow \mathrm{\underline{Hom}_\ell}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="LeftInternalHomOnMorphismsWithGivenLeftInternalHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{Hom}_\ell}(a',b)</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}_\ell}(a,b')</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}_\ell}(\alpha,\beta): \mathrm{\underline{Hom}_\ell}(a',b) \rightarrow \mathrm{\underline{Hom}_\ell}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftClosedMonoidalEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}_\ell}(a,b) \otimes a, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}_\ell}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="LeftClosedMonoidalEvaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{Hom}_\ell}(a,b) \otimes a</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}_\ell}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftClosedMonoidalCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{Hom}_\ell}(a, b \otimes a) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}_\ell}(a, b \otimes a)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="LeftClosedMonoidalCoevaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{Hom}_\ell}(a, b \otimes a)</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}_\ell}(a, b \otimes a)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="TensorProductToLeftInternalHomAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}_\ell}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: a \otimes b \rightarrow c</Math>.
 The output is a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}_\ell}(b,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, i" Name="TensorProductToLeftInternalHomAdjunctMorphismWithGivenLeftInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, i )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: a \otimes b \rightarrow c</Math> and an object <Math>i = \mathrm{\underline{Hom}_\ell}(b,c)</Math>.
 The output is a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}_\ell}(b,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="LeftInternalHomToTensorProductAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}_\ell}(b,c)</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, t" Name="LeftInternalHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(t, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}_\ell}(b,c)</Math> and an object <Math>t = a \otimes b</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="LeftClosedMonoidalPreComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}_\ell}(a,b) \otimes \mathrm{\underline{Hom}_\ell}(b,c), \mathrm{\underline{Hom}_\ell}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{LeftClosedMonoidalPreComposeMorphism}_{a,b,c}: \mathrm{\underline{Hom}_\ell}(a,b) \otimes \mathrm{\underline{Hom}_\ell}(b,c) \rightarrow \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="LeftClosedMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}_\ell}(a,b) \otimes \mathrm{\underline{Hom}_\ell}(b,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{LeftClosedMonoidalPreComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}_\ell}(a,b) \otimes \mathrm{\underline{Hom}_\ell}(b,c) \rightarrow \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="LeftClosedMonoidalPostComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}_\ell}(b,c) \otimes \mathrm{\underline{Hom}_\ell}(a,b), \mathrm{\underline{Hom}_\ell}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{LeftClosedMonoidalPostComposeMorphism}_{a,b,c}: \mathrm{\underline{Hom}_\ell}(b,c) \otimes \mathrm{\underline{Hom}_\ell}(a,b) \rightarrow \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="LeftClosedMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}_\ell}(b,c) \otimes \mathrm{\underline{Hom}_\ell}(a,b)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{LeftClosedMonoidalPostComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}_\ell}(b,c) \otimes \mathrm{\underline{Hom}_\ell}(a,b) \rightarrow \mathrm{\underline{Hom}_\ell}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftDualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its dual object <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LeftDualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b^{\vee}, a^{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="LeftDualOnMorphismsWithGivenLeftDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b^{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a^{\vee}</Math>.
 The output is the dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftClosedMonoidalEvaluationForLeftDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes a, 1 )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="LeftClosedMonoidalEvaluationForLeftDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes a</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = 1</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismToLeftBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a^{\vee})^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="MorphismToLeftBidualWithGivenLeftBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>r = (a^{\vee})^{\vee}</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="TensorProductLeftInternalHomCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}_\ell}(a,a') \otimes \mathrm{\underline{Hom}_\ell}(b,b'), \mathrm{\underline{Hom}_\ell}(a \otimes b,a' \otimes b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductLeftInternalHomCompatibilityMorphism}_{a,a',b,b'}: \mathrm{\underline{Hom}_\ell}(a,a') \otimes \mathrm{\underline{Hom}_\ell}(b,b') \rightarrow \mathrm{\underline{Hom}_\ell}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="TensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{Hom}_\ell}(a,a') \otimes \mathrm{\underline{Hom}_\ell}(b,b')</Math> and <Math>r = \mathrm{\underline{Hom}_\ell}(a \otimes b,a' \otimes b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}_\ell}(a,a') \otimes \mathrm{\underline{Hom}_\ell}(b,b') \rightarrow \mathrm{\underline{Hom}_\ell}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="TensorProductLeftDualityCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b^{\vee}, (a \otimes b)^{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductLeftDualityCompatibilityMorphism}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="TensorProductLeftDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b^{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = (a \otimes b)^{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductLeftDualityCompatibilityMorphismWithGivenObjects}_{a,b}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromTensorProductToLeftInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}_\ell}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToLeftInternalHom}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromTensorProductToLeftInternalHomWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToLeftInternalHomWithGivenObjects}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a^{\vee}, \mathrm{\underline{Hom}_\ell}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit}_{a}: a^{\vee} \rightarrow \mathrm{\underline{Hom}_\ell}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}_\ell}(a,1), a^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject}_{a}: \mathrm{\underline{Hom}_\ell}(a,1) \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfLeftDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(t, a^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: t \otimes a \rightarrow 1</Math>.
 The output is the morphism <Math>t \rightarrow a^{\vee}</Math>
 given by the universal property of <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LeftClosedMonoidalLambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, \mathrm{\underline{Hom}_\ell}(a,b) )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math>1 \rightarrow \mathrm{\underline{Hom}_\ell}(a,b)</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="LeftClosedMonoidalLambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow \mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToLeftInternalHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{Hom}_\ell}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}_\ell}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToLeftInternalHomWithGivenLeftInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}_\ell}(1,a)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}_\ell}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftInternalHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}_\ell}(1,a),a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}_\ell}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromLeftInternalHomToObjectWithGivenLeftInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s,a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{Hom}_\ell}(1,a)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}_\ell}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Closed_Monoidal_Categories">
<Heading>Closed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a right adjoint (denoted by <Math>\mathrm{\underline{Hom}_\ell}(b,-)</Math>)
is called a <Emph>closed monoidal category</Emph>.
<P/>
If no operations involving duals are installed manually, the dual objects will be derived as <Math>a^\vee \coloneqq \mathrm{\underline{Hom}_\ell}(a,1)</Math>.
<P/>
The corresponding GAP property is called
<C>IsClosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal hom object <Math>\mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="InternalHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a',b), \mathrm{\underline{Hom}}(a,b') )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}}(\alpha,\beta): \mathrm{\underline{Hom}}(a',b) \rightarrow \mathrm{\underline{Hom}}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="InternalHomOnMorphismsWithGivenInternalHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{Hom}}(a',b)</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,b')</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}}(\alpha,\beta): \mathrm{\underline{Hom}}(a',b) \rightarrow \mathrm{\underline{Hom}}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="ClosedMonoidalRightEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes \mathrm{\underline{Hom}}(a,b), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the right evaluation morphism <Math>\mathrm{ev}_{a,b}:a \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="ClosedMonoidalRightEvaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = a \otimes \mathrm{\underline{Hom}}(a,b)</Math>.
 The output is the right evaluation morphism <Math>\mathrm{ev}_{a,b}: a \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="ClosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{Hom}}(a, a \otimes b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the right coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}}(a, a \otimes b)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="ClosedMonoidalRightCoevaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{Hom}}(a, a \otimes b)</Math>.
 The output is the right coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}}(a, a \otimes b)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="TensorProductToInternalHomRightAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: a \otimes b \rightarrow c</Math>.
 The output is a morphism <Math>g: b \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, i" Name="TensorProductToInternalHomRightAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, i )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: a \otimes b \rightarrow c</Math> and an object <Math>i = \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is a morphism <Math>g: b \rightarrow i</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="TensorProductToInternalHomRightAdjunctionIsomorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( H(a \otimes b, c), H(b, \mathrm{\underline{Hom}}(a,c)) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the tri-natural isomorphism
 <Math>H(a \otimes b, c) \to H(b, \mathrm{\underline{Hom}}(a,c))</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="TensorProductToInternalHomRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are fives objects <Math>s,a,b,c,r</Math>
 where <Math>s = H(a \otimes b, c)</Math> and <Math>r = H(b, \mathrm{\underline{Hom}}(a,c))</Math>.
 The output is the tri-natural isomorphism <Math>s \to r</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, g" Name="InternalHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math> and a morphism <Math>g: b \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, g, s" Name="InternalHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math>, a morphism <Math>g: b \rightarrow \mathrm{\underline{Hom}}(a,c)</Math> and an object <Math>s = a \otimes b</Math>.
 The output is a morphism <Math>f: s \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="InternalHomToTensorProductRightAdjunctionIsomorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( H(b, \mathrm{\underline{Hom}}(a,c)), H(a \otimes b, c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the tri-natural isomorphism
 <Math>H(b, \mathrm{\underline{Hom}}(a,c)) \to H(a \otimes b, c)</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="InternalHomToTensorProductRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are fives objects <Math>s,a,b,c,r</Math>
 where <Math>s = H(b, \mathrm{\underline{Hom}}(a,c))</Math> and <Math>r = H(a \otimes b, c)</Math>.
 The output is the tri-natural isomorphism <Math>s \to r</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="ClosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes a, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the left evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="ClosedMonoidalLeftEvaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{Hom}}(a,b) \otimes a</Math>.
 The output is the left evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="ClosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{Hom}}(a, b \otimes a) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the left coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}}(a, b \otimes a)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="ClosedMonoidalLeftCoevaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{Hom}}(a, b \otimes a)</Math>.
 The output is the left coevaluation morphism <Math>\mathrm{coev}_{a,b}: b \rightarrow \mathrm{\underline{Hom}}(a, b \otimes a)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="TensorProductToInternalHomLeftAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: a \otimes b \rightarrow c</Math>.
 The output is a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, i" Name="TensorProductToInternalHomLeftAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, i )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: a \otimes b \rightarrow c</Math> and an object <Math>i = \mathrm{\underline{Hom}}(b,c)</Math>.
 The output is a morphism <Math>g: a \rightarrow i</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="TensorProductToInternalHomLeftAdjunctionIsomorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( H(a \otimes b, c), H(a, \mathrm{\underline{Hom}}(b,c)) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the tri-natural isomorphism
 <Math>H(a \otimes b, c) \to H(a, \mathrm{\underline{Hom}}(b,c))</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="TensorProductToInternalHomLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are fives objects <Math>s,a,b,c,r</Math>
 where <Math>s = H(a \otimes b, c)</Math> and <Math>r = H(a, \mathrm{\underline{Hom}}(b,c))</Math>.
 The output is the tri-natural isomorphism <Math>s \to r</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="InternalHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, s" Name="InternalHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math> and an object <Math>s = a \otimes b</Math>.
 The output is a morphism <Math>f: s \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="InternalHomToTensorProductLeftAdjunctionIsomorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( H(a, \mathrm{\underline{Hom}}(b,c)), H(a \otimes b, c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the tri-natural isomorphism
 <Math>H(a, \mathrm{\underline{Hom}}(b,c)) \to H(a \otimes b, c)</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="InternalHomToTensorProductLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are fives objects <Math>s,a,b,c,r</Math>
 where <Math>s = H(a, \mathrm{\underline{Hom}}(b,c))</Math> and <Math>r = H(a \otimes b, c)</Math>.
 The output is the tri-natural isomorphism <Math>s \to r</Math>
 in the range category of the homomorphism structure <Math>H</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPreComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{MonoidalPreComposeMorphism}_{a,b,c}: \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{MonoidalPreComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPostComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{MonoidalPostComposeMorphism}_{a,b,c}: \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{MonoidalPostComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="DualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its dual object <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="DualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b^{\vee}, a^{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="DualOnMorphismsWithGivenDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b^{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a^{\vee}</Math>.
 The output is the dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="EvaluationForDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes a, 1 )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="EvaluationForDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes a</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = 1</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismToBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a^{\vee})^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="MorphismToBidualWithGivenBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>r = (a^{\vee})^{\vee}</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="TensorProductInternalHomCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b'), \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphism}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') \rightarrow \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="TensorProductInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math> and <Math>r = \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') \rightarrow \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="TensorProductDualityCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b^{\vee}, (a \otimes b)^{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductDualityCompatibilityMorphism}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="TensorProductDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b^{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = (a \otimes b)^{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductDualityCompatibilityMorphismWithGivenObjects}_{a,b}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromTensorProductToInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToInternalHom}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromTensorProductToInternalHomWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,b)</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromDualObjectToInternalHomIntoTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a^{\vee}, \mathrm{\underline{Hom}}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromDualObjectToInternalHomIntoTensorUnit}_{a}: a^{\vee} \rightarrow \mathrm{\underline{Hom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalHomIntoTensorUnitToDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}}(a,1), a^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromInternalHomIntoTensorUnitToDualObject}_{a}: \mathrm{\underline{Hom}}(a,1) \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(t, a^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: t \otimes a \rightarrow 1</Math>.
 The output is the morphism <Math>t \rightarrow a^{\vee}</Math>
 given by the universal property of <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math>1 \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="LambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToInternalHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{Hom}}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToInternalHomWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(1,a)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}}(1,a),a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromInternalHomToObjectWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s,a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{Hom}}(1,a)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Left_Coclosed_Monoidal_Categories">
<Heading>Left Coclosed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a left adjoint (denoted by <Math>\mathrm{\underline{coHom}}(-,b)</Math>)
is called a <Emph>left coclosed monoidal category</Emph>.
<P/>
If no operations involving left coduals are installed manually, the left codual objects will be derived as <Math>a_\vee \coloneqq \mathrm{\underline{coHom}}(1,a)</Math>.
<P/>
The corresponding GAP property is called
<C>IsLeftCoclosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="LeftInternalCoHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal cohom object <Math>\mathrm{\underline{coHom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="LeftInternalCoHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,b'), \mathrm{\underline{coHom}_\ell}(a',b) )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}_\ell}(\alpha,\beta): \mathrm{\underline{coHom}_\ell}(a,b') \rightarrow \mathrm{\underline{coHom}_\ell}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="LeftInternalCoHomOnMorphismsWithGivenLeftInternalCoHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}_\ell}(a,b')</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}_\ell}(a',b)</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}_\ell}(\alpha,\beta): \mathrm{\underline{coHom}_\ell}(a,b') \rightarrow \mathrm{\underline{coHom}_\ell}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftCoclosedMonoidalEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{coHom}_\ell}(b,a) \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow \mathrm{\underline{coHom}_\ell}(b,a) \otimes a</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="LeftCoclosedMonoidalEvaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{coHom}_\ell}(b,a) \otimes a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow \mathrm{\underline{coHom}_\ell}(b,a) \otimes a</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftCoclosedMonoidalCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(b \otimes a, a), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}_\ell}(b \otimes a, a) \rightarrow b</Math>, i.e.,
 the counit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="LeftCoclosedMonoidalCoevaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{coHom}_\ell}(b \otimes a, a)</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}_\ell}(b \otimes a, a) \rightarrow b</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="TensorProductToLeftInternalCoHomAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,c), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow b \otimes c</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow b</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, i" Name="TensorProductToLeftInternalCoHomAdjunctMorphismWithGivenLeftInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( i, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow b \otimes c</Math> and an object <Math>i = \mathrm{\underline{coHom}_\ell}(a,c)</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow b</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, f" Name="LeftInternalCoHomToTensorProductAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, b \otimes c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math> and a morphism <Math>f: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow b</Math>.
 The output is a morphism <Math>g: a \rightarrow b \otimes c</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, f, t" Name="LeftInternalCoHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, t )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math>, a morphism <Math>f: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow b</Math> and an object <Math>t = b \otimes c</Math>.
 The output is a morphism <Math>g: a \rightarrow b \otimes c</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="LeftCoclosedMonoidalPreCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,c), \mathrm{\underline{coHom}_\ell}(b,c) \otimes \mathrm{\underline{coHom}_\ell}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{LeftCoclosedMonoidalPreCoComposeMorphism}_{a,b,c}: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow \mathrm{\underline{coHom}_\ell}(b,c) \otimes \mathrm{\underline{coHom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="LeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}_\ell}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(b,c)</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{LeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow \mathrm{\underline{coHom}_\ell}(b,c) \otimes \mathrm{\underline{coHom}_\ell}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="LeftCoclosedMonoidalPostCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,c), \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{LeftCoclosedMonoidalPostCoComposeMorphism}_{a,b,c}: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="LeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}_\ell}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}_\ell}(b,c) \otimes \mathrm{\underline{coHom}_\ell}(a,b)</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{LeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}_\ell}(a,c) \rightarrow \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftCoDualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its codual object <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LeftCoDualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b_{\vee}, a_{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its codual morphism <Math>\alpha_{\vee}: b_{\vee} \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="LeftCoDualOnMorphismsWithGivenLeftCoDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b_{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a_{\vee}</Math>.
 The output is the dual morphism <Math>\alpha_{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftCoclosedMonoidalEvaluationForLeftCoDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, a_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="LeftCoclosedMonoidalEvaluationForLeftCoDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = 1</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = a_{\vee} \otimes a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismFromLeftCoBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a_{\vee})_{\vee}, a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="MorphismFromLeftCoBidualWithGivenLeftCoBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, a)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>s = (a_{\vee})_{\vee}</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="LeftInternalCoHomTensorProductCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a \otimes a', b \otimes b'), \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(a',b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{LeftInternalCoHomTensorProductCompatibilityMorphism}_{a,a',b,b'}: \mathrm{\underline{coHom}_\ell}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="LeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{coHom}_\ell}(a \otimes a', b \otimes b')</Math> and <Math>r = \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(a',b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{LeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}_\ell}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}_\ell}(a,b) \otimes \mathrm{\underline{coHom}_\ell}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="LeftCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b)_{\vee}, a_{\vee} \otimes b_{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{LeftCoDualityTensorProductCompatibilityMorphism}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="LeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b)_{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = a_{\vee} \otimes b_{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{LeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects}_{a,b}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromLeftInternalCoHomToTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,b), b_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromLeftInternalCoHomToTensorProduct}_{a,b}: \mathrm{\underline{coHom}_\ell}(a,b) \rightarrow b_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromLeftInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}_\ell}(a,b)</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = b_{\vee} \otimes a</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromLeftInternalCoHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}_\ell}(a,b) \rightarrow a \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, \mathrm{\underline{coHom}_\ell}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit}_{a}: a_{\vee} \rightarrow \mathrm{\underline{coHom}_\ell}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}_\ell}(1,a), a_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject}_{a}: \mathrm{\underline{coHom}_\ell}(1,a) \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfLeftCoDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, t)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow t \otimes a</Math>.
 The output is the morphism <Math>a_{\vee} \rightarrow t</Math>
 given by the universal property of <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LeftCoclosedMonoidalLambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}_\ell}(a,b), 1 )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math> \mathrm{\underline{coHom}_\ell}(a,b) \rightarrow 1</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="LeftCoclosedMonoidalLambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: \mathrm{\underline{coHom}_\ell}(a,b) \rightarrow 1</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToLeftInternalCoHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{coHom}_\ell}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}_\ell}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToLeftInternalCoHomWithGivenLeftInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}_\ell}(a,1)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}_\ell}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromLeftInternalCoHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}_\ell}(a,1), a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}_\ell}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromLeftInternalCoHomToObjectWithGivenLeftInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{coHom}_\ell}(a,1)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}_\ell}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Coclosed_Monoidal_Categories">
<Heading>Coclosed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a left adjoint (denoted by <Math>\mathrm{\underline{coHom}}(-,b)</Math>)
is called a <Emph>coclosed monoidal category</Emph>.
<P/>
If no operations involving coduals are installed manually, the codual objects will be derived as <Math>a_\vee \coloneqq \mathrm{\underline{coHom}}(1,a)</Math>.
<P/>
The corresponding GAP property is called
<C>IsCoclosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalCoHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal cohom object <Math>\mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="InternalCoHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b'), \mathrm{\underline{coHom}}(a',b) )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}}(\alpha,\beta): \mathrm{\underline{coHom}}(a,b') \rightarrow \mathrm{\underline{coHom}}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="InternalCoHomOnMorphismsWithGivenInternalCoHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}}(a,b')</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a',b)</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}}(\alpha,\beta): \mathrm{\underline{coHom}}(a,b') \rightarrow \mathrm{\underline{coHom}}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedMonoidalRightEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, a \otimes \mathrm{\underline{coHom}}(b,a) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the coclosed right evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow a \otimes \mathrm{\underline{coHom}}(b,a)</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="CoclosedMonoidalRightEvaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = a \otimes \mathrm{\underline{coHom}}(b,a)</Math>.
 The output is the coclosed right evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow a \otimes \mathrm{\underline{coHom}}(b,a)</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes b, a), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coclosed right coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(a \otimes b, a) \rightarrow b</Math>, i.e.,
 the counit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="CoclosedMonoidalRightCoevaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{coHom}}(a \otimes b, a)</Math>.
 The output is the coclosed right coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(a \otimes b, a) \rightarrow b</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="TensorProductToInternalCoHomRightAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), c )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow b \otimes c</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, i" Name="TensorProductToInternalCoHomRightAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( i, c )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow b \otimes c</Math> and an object <Math>i = \mathrm{\underline{coHom}}(a,b)</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="InternalCoHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, b \otimes c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>.
 The output is a morphism <Math>g: a \rightarrow b \otimes c</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, t" Name="InternalCoHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, t )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math> and an object <Math>t = b \otimes c</Math>.
 The output is a morphism <Math>g: a \rightarrow t</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, \mathrm{\underline{coHom}}(b,a) \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the coclosed left evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow \mathrm{\underline{coHom}}(b,a) \otimes a</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="CoclosedMonoidalLeftEvaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b, r )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{coHom}}(b,a) \otimes a</Math>.
 The output is the coclosed left evaluation morphism <Math>\mathrm{coclev}_{a,b}: b \rightarrow \mathrm{\underline{coHom}}(b,a) \otimes a</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(b \otimes a, a), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coclosed left coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(b \otimes a, a) \rightarrow b</Math>, i.e.,
 the counit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="CoclosedMonoidalLeftCoevaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{coHom}}(b \otimes a, a)</Math>.
 The output is the coclosed left coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(b \otimes a, a) \rightarrow b</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="TensorProductToInternalCoHomLeftAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow b \otimes c</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,c) \rightarrow b</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, i" Name="TensorProductToInternalCoHomLeftAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( i, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow b \otimes c</Math> and an object <Math>i = \mathrm{\underline{coHom}}(a,c)</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,c) \rightarrow b</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, f" Name="InternalCoHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, b \otimes c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math> and a morphism <Math>f: \mathrm{\underline{coHom}}(a,c) \rightarrow b</Math>.
 The output is a morphism <Math>g: a \rightarrow b \otimes c</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, c, f, t" Name="InternalCoHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, t )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,c</Math>, a morphism <Math>f: \mathrm{\underline{coHom}}(a,c) \rightarrow b</Math> and an object <Math>t = b \otimes c</Math>.
 The output is a morphism <Math>g: a \rightarrow t</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPreCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{MonoidalPreCoComposeMorphism}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{MonoidalPreCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPostCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{MonoidalPostCoComposeMorphism}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{MonoidalPostCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoDualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its codual object <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoDualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b_{\vee}, a_{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its codual morphism <Math>\alpha_{\vee}: b_{\vee} \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="CoDualOnMorphismsWithGivenCoDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b_{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a_{\vee}</Math>.
 The output is the dual morphism <Math>\alpha_{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoclosedEvaluationForCoDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, a_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoclosedEvaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = 1</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = a_{\vee} \otimes a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismFromCoBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a_{\vee})_{\vee}, a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="MorphismFromCoBidualWithGivenCoBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, a)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>s = (a_{\vee})_{\vee}</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="InternalCoHomTensorProductCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes a', b \otimes b'), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphism}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math> and <Math>r = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="CoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b)_{\vee}, a_{\vee} \otimes b_{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{CoDualityTensorProductCompatibilityMorphism}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="CoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b)_{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = a_{\vee} \otimes b_{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{CoDualityTensorProductCompatibilityMorphismWithGivenObjects}_{a,b}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromInternalCoHomToTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), b_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromInternalCoHomToTensorProduct}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow b_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}}(a,b)</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = b_{\vee} \otimes a</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow a \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, \mathrm{\underline{coHom}}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit}_{a}: a_{\vee} \rightarrow \mathrm{\underline{coHom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}}(1,a), a_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject}_{a}: \mathrm{\underline{coHom}}(1,a) \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfCoDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, t)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow t \otimes a</Math>.
 The output is the morphism <Math>a_{\vee} \rightarrow t</Math>
 given by the universal property of <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoLambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), 1 )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math> \mathrm{\underline{coHom}}(a,b) \rightarrow 1</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="CoLambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: \mathrm{\underline{coHom}}(a,b) \rightarrow 1</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToInternalCoHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{coHom}}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, r)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a,1)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalCoHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}}(a,1), a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(s, a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{coHom}}(a,1)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Closed_Monoidal_Categories">
<Heading>Symmetric Closed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which is symmetric and closed
is called a <Emph>symmetric closed monoidal category</Emph>.
<P/>
The corresponding GAP property is given by
<C>IsSymmetricClosedMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Coclosed_Monoidal_Categories">
<Heading>Symmetric Coclosed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which is symmetric and coclosed
is called a <Emph>symmetric coclosed monoidal category</Emph>.
<P/>
The corresponding GAP property is given by
<C>IsSymmetricCoclosedMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Rigid_Symmetric_Closed_Monoidal_Categories">
<Heading>Rigid Symmetric Closed Monoidal Categories</Heading>

<P/>
A symmetric closed monoidal category <Math>\mathbf{C}</Math> satisfying
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{Hom}_\ell}(a, a') \otimes \mathrm{\underline{Hom}_\ell}(b, b') \rightarrow \mathrm{\underline{Hom}_\ell}(a \otimes b, a' \otimes b')</Math>
 is an isomorphism,
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>a \rightarrow \mathrm{\underline{Hom}_\ell}(\mathrm{\underline{Hom}_\ell}(a, 1), 1)</Math>
 is an isomorphism
is called a <Emph>rigid symmetric closed monoidal category</Emph>.
<P/>
If no operations involving the closed structure are installed manually, the internal hom objects will be derived as
<Math>\mathrm{\underline{Hom}_\ell}(a,b) \coloneqq a^\vee \otimes b</Math> and, in particular, <Math>\mathrm{\underline{Hom}_\ell}(a,1) \coloneqq a^\vee \otimes 1</Math>.
<P/>
The corresponding GAP property is given by
<C>IsRigidSymmetricClosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromTensorProductWithDualObjectToInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{IsomorphismFromTensorProductWithDualObjectToInternalHom}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromInternalHomToTensorProductWithDualObject" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{IsomorphismFromTensorProductWithDualObjectToInternalHom}</Math>, namely
 <Math>\mathrm{IsomorphismFromInternalHomToTensorProductWithDualObject}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromInternalHomToTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromInternalHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromInternalHomToTensorProductWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{Hom}}(a,b)</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = a^{\vee} \otimes b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromInternalHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="TensorProductInternalHomCompatibilityMorphismInverse" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'), \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') )</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b') \rightarrow \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'), \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math> and <Math>r = \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b') \rightarrow \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoevaluationForDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,a \otimes a^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a}:1 \rightarrow a \otimes a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoevaluationForDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,a \otimes a^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = 1</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = a \otimes a^{\vee}</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a}:1 \rightarrow a \otimes a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="TraceMap" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an endomorphism <Math>\alpha: a \rightarrow a</Math>.
 The output is the trace morphism <Math>\mathrm{trace}_{\alpha}: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RankMorphism" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the rank morphism <Math>\mathrm{rank}_a: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismFromBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a^{\vee})^{\vee},a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the morphism to the bidual <Math>(a^{\vee})^{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="MorphismFromBidualWithGivenBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a^{\vee})^{\vee},a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = (a^{\vee})^{\vee}</Math>.
 The output is the inverse of the morphism to the bidual <Math>(a^{\vee})^{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Rigid_Symmetric_Coclosed_Monoidal_Categories">
<Heading>Rigid Symmetric Coclosed Monoidal Categories</Heading>

<P/>
A symmetric coclosed monoidal category <Math>\mathbf{C}</Math> satisfying
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a, b) \otimes \mathrm{\underline{coHom}}(a', b')</Math>
 is an isomorphism,
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{coHom}}(1, \mathrm{\underline{coHom}}(1, a)) \rightarrow a</Math>
 is an isomorphism
is called a <Emph>rigid symmetric coclosed monoidal category</Emph>.
<P/>
If no operations involving the coclosed structure are installed manually, the internal cohom objects will be derived as
<Math>\mathrm{\underline{coHom}}(a,b) \coloneqq a \otimes b_\vee</Math> and, in particular, <Math>\mathrm{\underline{coHom}}(1,a) \coloneqq 1 \otimes a_\vee</Math>.
<P/>
The corresponding GAP property is given by
<C>IsRigidSymmetricCoclosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromInternalCoHomToTensorProductWithCoDualObject" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), b_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{IsomorphismFromInternalCoHomToTensorProductWithCoDualObjectWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow b_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{IsomorphismFromInternalCoHomToTensorProductWithCoDualObject}</Math>, namely
 <Math>\mathrm{IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromTensorProductToInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromTensorProductToInternalCoHomWithGivenObjects}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromTensorProductToInternalCoHomWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s_{\vee} = a \otimes b</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(b,a)</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromTensorProductToInternalCoHomWithGivenObjects}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="InternalCoHomTensorProductCompatibilityMorphismInverse" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'), \mathrm{\underline{coHom}}(a \otimes a', b \otimes b' )</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b') \rightarrow \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'), \mathrm{\underline{coHom}}(a \otimes a', b \otimes b' )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math> and <Math>r = \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b') \rightarrow \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoclosedCoevaluationForCoDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes a_{\vee}, 1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a}: a \otimes a_{\vee} \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoclosedCoevaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes a_{\vee}, 1)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes a_{\vee}</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = 1</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a}: a \otimes a_{\vee} \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoTraceMap" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an endomorphism <Math>\alpha: a \rightarrow a</Math>.
 The output is the cotrace morphism <Math>\mathrm{cotrace}_{\alpha}: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoRankMorphism" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the corank morphism <Math>\mathrm{corank}_a: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismToCoBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a_{\vee})_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the morphism from the cobidual <Math>a \rightarrow (a_{\vee})_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="MorphismToCoBidualWithGivenCoBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,(a_{\vee})_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = (a_{\vee})_{\vee}</Math>.
 The output is the inverse of the morphism from the cobidual <Math>a \rightarrow (a_{\vee})_{\vee}</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Convenience_Methods">
<Heading>Convenience Methods</Heading>

<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal hom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal Hom object
 <Math>\mathrm{\underline{Hom}}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal hom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="InternalCoHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal cohom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal cohom object
 <Math>\mathrm{\underline{coHom}}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal cohom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftInternalHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal hom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal Hom object
 <Math>\mathrm{\underline{Hom}_\ell}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal hom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="LeftInternalCoHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal cohom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal cohom object
 <Math>\mathrm{\underline{coHom}_\ell}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal cohom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Add-methods">
<Heading>Add-methods</Heading>

<P/>
<ManSection Label="AutoDoc_generated_group1">
  <Oper Arg="C, F" Name="AddLeftDistributivityExpanding" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDistributivityExpanding" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityExpanding</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, L ) \mapsto \mathtt{LeftDistributivityExpanding}(a, L)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group2">
  <Oper Arg="C, F" Name="AddLeftDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityExpandingWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, L, r ) \mapsto \mathtt{LeftDistributivityExpandingWithGivenObjects}(s, a, L, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group3">
  <Oper Arg="C, F" Name="AddLeftDistributivityFactoring" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDistributivityFactoring" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityFactoring</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, L ) \mapsto \mathtt{LeftDistributivityFactoring}(a, L)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group4">
  <Oper Arg="C, F" Name="AddLeftDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityFactoringWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, L, r ) \mapsto \mathtt{LeftDistributivityFactoringWithGivenObjects}(s, a, L, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group5">
  <Oper Arg="C, F" Name="AddRightDistributivityExpanding" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightDistributivityExpanding" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityExpanding</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( L, a ) \mapsto \mathtt{RightDistributivityExpanding}(L, a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group6">
  <Oper Arg="C, F" Name="AddRightDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityExpandingWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, L, a, r ) \mapsto \mathtt{RightDistributivityExpandingWithGivenObjects}(s, L, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group7">
  <Oper Arg="C, F" Name="AddRightDistributivityFactoring" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightDistributivityFactoring" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityFactoring</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( L, a ) \mapsto \mathtt{RightDistributivityFactoring}(L, a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group8">
  <Oper Arg="C, F" Name="AddRightDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityFactoringWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, L, a, r ) \mapsto \mathtt{RightDistributivityFactoringWithGivenObjects}(s, L, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group9">
  <Oper Arg="C, F" Name="AddBraiding" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddBraiding" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>Braiding</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{Braiding}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group10">
  <Oper Arg="C, F" Name="AddBraidingInverse" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddBraidingInverse" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingInverse</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{BraidingInverse}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group11">
  <Oper Arg="C, F" Name="AddBraidingInverseWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddBraidingInverseWithGivenTensorProducts" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingInverseWithGivenTensorProducts</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{BraidingInverseWithGivenTensorProducts}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group12">
  <Oper Arg="C, F" Name="AddBraidingWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddBraidingWithGivenTensorProducts" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingWithGivenTensorProducts</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{BraidingWithGivenTensorProducts}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group13">
  <Oper Arg="C, F" Name="AddClosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalLeftCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{ClosedMonoidalLeftCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group14">
  <Oper Arg="C, F" Name="AddClosedMonoidalLeftCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalLeftCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalLeftCoevaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{ClosedMonoidalLeftCoevaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group15">
  <Oper Arg="C, F" Name="AddClosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalLeftEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{ClosedMonoidalLeftEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group16">
  <Oper Arg="C, F" Name="AddClosedMonoidalLeftEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalLeftEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalLeftEvaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{ClosedMonoidalLeftEvaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group17">
  <Oper Arg="C, F" Name="AddClosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalRightCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{ClosedMonoidalRightCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group18">
  <Oper Arg="C, F" Name="AddClosedMonoidalRightCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalRightCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalRightCoevaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{ClosedMonoidalRightCoevaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group19">
  <Oper Arg="C, F" Name="AddClosedMonoidalRightEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalRightEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalRightEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{ClosedMonoidalRightEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group20">
  <Oper Arg="C, F" Name="AddClosedMonoidalRightEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddClosedMonoidalRightEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>ClosedMonoidalRightEvaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{ClosedMonoidalRightEvaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group21">
  <Oper Arg="C, F" Name="AddDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddDualOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{DualOnMorphisms}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group22">
  <Oper Arg="C, F" Name="AddDualOnMorphismsWithGivenDuals" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddDualOnMorphismsWithGivenDuals" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnMorphismsWithGivenDuals</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{DualOnMorphismsWithGivenDuals}(s, alpha, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group23">
  <Oper Arg="C, F" Name="AddDualOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddDualOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{DualOnObjects}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group24">
  <Oper Arg="C, F" Name="AddEvaluationForDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddEvaluationForDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationForDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{EvaluationForDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group25">
  <Oper Arg="C, F" Name="AddEvaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddEvaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationForDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{EvaluationForDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group26">
  <Oper Arg="C, F" Name="AddInternalHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha, beta ) \mapsto \mathtt{InternalHomOnMorphisms}(alpha, beta)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group27">
  <Oper Arg="C, F" Name="AddInternalHomOnMorphismsWithGivenInternalHoms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomOnMorphismsWithGivenInternalHoms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnMorphismsWithGivenInternalHoms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{InternalHomOnMorphismsWithGivenInternalHoms}(s, alpha, beta, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group28">
  <Oper Arg="C, F" Name="AddInternalHomOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{InternalHomOnObjects}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group29">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductLeftAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g ) \mapsto \mathtt{InternalHomToTensorProductLeftAdjunctMorphism}(b, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group30">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g, s ) \mapsto \mathtt{InternalHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct}(b, c, g, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group31">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductLeftAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductLeftAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductLeftAdjunctionIsomorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{InternalHomToTensorProductLeftAdjunctionIsomorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group32">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductLeftAdjunctionIsomorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{InternalHomToTensorProductLeftAdjunctionIsomorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group33">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductRightAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, g ) \mapsto \mathtt{InternalHomToTensorProductRightAdjunctMorphism}(a, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group34">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, g, s ) \mapsto \mathtt{InternalHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct}(a, c, g, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group35">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductRightAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductRightAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductRightAdjunctionIsomorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{InternalHomToTensorProductRightAdjunctionIsomorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group36">
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalHomToTensorProductRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductRightAdjunctionIsomorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{InternalHomToTensorProductRightAdjunctionIsomorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group37">
  <Oper Arg="C, F" Name="AddIsomorphismFromDualObjectToInternalHomIntoTensorUnit" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromDualObjectToInternalHomIntoTensorUnit" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromDualObjectToInternalHomIntoTensorUnit</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromDualObjectToInternalHomIntoTensorUnit}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group38">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomIntoTensorUnitToDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalHomIntoTensorUnitToDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomIntoTensorUnitToDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalHomIntoTensorUnitToDualObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group39">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalHomToObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalHomToObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group40">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToObjectWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalHomToObjectWithGivenInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToObjectWithGivenInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromInternalHomToObjectWithGivenInternalHom}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group41">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToInternalHom}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group42">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalHomWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToInternalHomWithGivenInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalHomWithGivenInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToInternalHomWithGivenInternalHom}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group43">
  <Oper Arg="C, F" Name="AddLambdaElimination" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLambdaElimination" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LambdaElimination</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{LambdaElimination}(a, b, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group44">
  <Oper Arg="C, F" Name="AddLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLambdaIntroduction" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LambdaIntroduction</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{LambdaIntroduction}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group45">
  <Oper Arg="C, F" Name="AddMonoidalPostComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPostComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPostComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group46">
  <Oper Arg="C, F" Name="AddMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPostComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group47">
  <Oper Arg="C, F" Name="AddMonoidalPreComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPreComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPreComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group48">
  <Oper Arg="C, F" Name="AddMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPreComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group49">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromTensorProductToInternalHom}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group50">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalHomWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToInternalHomWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalHomWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromTensorProductToInternalHomWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group51">
  <Oper Arg="C, F" Name="AddMorphismToBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismToBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group52">
  <Oper Arg="C, F" Name="AddMorphismToBidualWithGivenBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToBidualWithGivenBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToBidualWithGivenBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{MorphismToBidualWithGivenBidual}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group53">
  <Oper Arg="C, F" Name="AddTensorProductDualityCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductDualityCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductDualityCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{TensorProductDualityCompatibilityMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group54">
  <Oper Arg="C, F" Name="AddTensorProductDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductDualityCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{TensorProductDualityCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group55">
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductInternalHomCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphism}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group56">
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group57">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomLeftAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f ) \mapsto \mathtt{TensorProductToInternalHomLeftAdjunctMorphism}(a, b, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group58">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomLeftAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomLeftAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomLeftAdjunctMorphismWithGivenInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f, i ) \mapsto \mathtt{TensorProductToInternalHomLeftAdjunctMorphismWithGivenInternalHom}(a, b, f, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group59">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomLeftAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomLeftAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomLeftAdjunctionIsomorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{TensorProductToInternalHomLeftAdjunctionIsomorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group60">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomLeftAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomLeftAdjunctionIsomorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{TensorProductToInternalHomLeftAdjunctionIsomorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group61">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomRightAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomRightAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomRightAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f ) \mapsto \mathtt{TensorProductToInternalHomRightAdjunctMorphism}(a, b, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group62">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomRightAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomRightAdjunctMorphismWithGivenInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomRightAdjunctMorphismWithGivenInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f, i ) \mapsto \mathtt{TensorProductToInternalHomRightAdjunctMorphismWithGivenInternalHom}(a, b, f, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group63">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomRightAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomRightAdjunctionIsomorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomRightAdjunctionIsomorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{TensorProductToInternalHomRightAdjunctionIsomorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group64">
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalHomRightAdjunctionIsomorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomRightAdjunctionIsomorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{TensorProductToInternalHomRightAdjunctionIsomorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group65">
  <Oper Arg="C, F" Name="AddUniversalPropertyOfDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddUniversalPropertyOfDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfDual}(t, a, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group66">
  <Oper Arg="C, F" Name="AddCoDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoDualOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{CoDualOnMorphisms}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group67">
  <Oper Arg="C, F" Name="AddCoDualOnMorphismsWithGivenCoDuals" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoDualOnMorphismsWithGivenCoDuals" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnMorphismsWithGivenCoDuals</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{CoDualOnMorphismsWithGivenCoDuals}(s, alpha, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group68">
  <Oper Arg="C, F" Name="AddCoDualOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoDualOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{CoDualOnObjects}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group69">
  <Oper Arg="C, F" Name="AddCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualityTensorProductCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{CoDualityTensorProductCompatibilityMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group70">
  <Oper Arg="C, F" Name="AddCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualityTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{CoDualityTensorProductCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group71">
  <Oper Arg="C, F" Name="AddCoLambdaElimination" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoLambdaElimination" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoLambdaElimination</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{CoLambdaElimination}(a, b, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group72">
  <Oper Arg="C, F" Name="AddCoLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoLambdaIntroduction" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoLambdaIntroduction</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{CoLambdaIntroduction}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group73">
  <Oper Arg="C, F" Name="AddCoclosedEvaluationForCoDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedEvaluationForCoDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationForCoDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{CoclosedEvaluationForCoDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group74">
  <Oper Arg="C, F" Name="AddCoclosedEvaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedEvaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationForCoDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoclosedEvaluationForCoDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group75">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalLeftCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalLeftCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedMonoidalLeftCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group76">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalLeftCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalLeftCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalLeftCoevaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{CoclosedMonoidalLeftCoevaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group77">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalLeftEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalLeftEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedMonoidalLeftEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group78">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalLeftEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalLeftEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalLeftEvaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{CoclosedMonoidalLeftEvaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group79">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalRightCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalRightCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedMonoidalRightCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group80">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalRightCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalRightCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalRightCoevaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{CoclosedMonoidalRightCoevaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group81">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalRightEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalRightEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalRightEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedMonoidalRightEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group82">
  <Oper Arg="C, F" Name="AddCoclosedMonoidalRightEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedMonoidalRightEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedMonoidalRightEvaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{CoclosedMonoidalRightEvaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group83">
  <Oper Arg="C, F" Name="AddInternalCoHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha, beta ) \mapsto \mathtt{InternalCoHomOnMorphisms}(alpha, beta)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group84">
  <Oper Arg="C, F" Name="AddInternalCoHomOnMorphismsWithGivenInternalCoHoms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomOnMorphismsWithGivenInternalCoHoms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnMorphismsWithGivenInternalCoHoms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{InternalCoHomOnMorphismsWithGivenInternalCoHoms}(s, alpha, beta, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group85">
  <Oper Arg="C, F" Name="AddInternalCoHomOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{InternalCoHomOnObjects}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group86">
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphism}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group87">
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group88">
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomToTensorProductLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductLeftAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, f ) \mapsto \mathtt{InternalCoHomToTensorProductLeftAdjunctMorphism}(a, c, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group89">
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, f, t ) \mapsto \mathtt{InternalCoHomToTensorProductLeftAdjunctMorphismWithGivenTensorProduct}(a, c, f, t)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group90">
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomToTensorProductRightAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductRightAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f ) \mapsto \mathtt{InternalCoHomToTensorProductRightAdjunctMorphism}(a, b, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group91">
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f, t ) \mapsto \mathtt{InternalCoHomToTensorProductRightAdjunctMorphismWithGivenTensorProduct}(a, b, f, t)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group92">
  <Oper Arg="C, F" Name="AddIsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group93">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomFromTensorUnitToCoDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalCoHomFromTensorUnitToCoDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group94">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalCoHomToObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalCoHomToObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group95">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group96">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToInternalCoHom}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group97">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group98">
  <Oper Arg="C, F" Name="AddMonoidalPostCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPostCoComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostCoComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPostCoComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group99">
  <Oper Arg="C, F" Name="AddMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostCoComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPostCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group100">
  <Oper Arg="C, F" Name="AddMonoidalPreCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPreCoComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreCoComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPreCoComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group101">
  <Oper Arg="C, F" Name="AddMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreCoComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPreCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group102">
  <Oper Arg="C, F" Name="AddMorphismFromCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismFromCoBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group103">
  <Oper Arg="C, F" Name="AddMorphismFromCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromCoBidualWithGivenCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{MorphismFromCoBidualWithGivenCoBidual}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group104">
  <Oper Arg="C, F" Name="AddMorphismFromInternalCoHomToTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromInternalCoHomToTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalCoHomToTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromInternalCoHomToTensorProduct}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group105">
  <Oper Arg="C, F" Name="AddMorphismFromInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalCoHomToTensorProductWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromInternalCoHomToTensorProductWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group106">
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalCoHomLeftAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomLeftAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g ) \mapsto \mathtt{TensorProductToInternalCoHomLeftAdjunctMorphism}(b, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group107">
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomLeftAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalCoHomLeftAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomLeftAdjunctMorphismWithGivenInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g, i ) \mapsto \mathtt{TensorProductToInternalCoHomLeftAdjunctMorphismWithGivenInternalCoHom}(b, c, g, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group108">
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomRightAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalCoHomRightAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomRightAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g ) \mapsto \mathtt{TensorProductToInternalCoHomRightAdjunctMorphism}(b, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group109">
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomRightAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToInternalCoHomRightAdjunctMorphismWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomRightAdjunctMorphismWithGivenInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g, i ) \mapsto \mathtt{TensorProductToInternalCoHomRightAdjunctMorphismWithGivenInternalCoHom}(b, c, g, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group110">
  <Oper Arg="C, F" Name="AddUniversalPropertyOfCoDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddUniversalPropertyOfCoDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfCoDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfCoDual}(t, a, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group111">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftDualObjectToLeftInternalHomIntoTensorUnit}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group112">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftInternalHomIntoTensorUnitToLeftDualObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group113">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalHomToObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalHomToObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalHomToObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftInternalHomToObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group114">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalHomToObjectWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalHomToObjectWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalHomToObjectWithGivenLeftInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromLeftInternalHomToObjectWithGivenLeftInternalHom}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group115">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToLeftInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToLeftInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToLeftInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToLeftInternalHom}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group116">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToLeftInternalHomWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToLeftInternalHomWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToLeftInternalHomWithGivenLeftInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToLeftInternalHomWithGivenLeftInternalHom}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group117">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftClosedMonoidalCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group118">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalCoevaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{LeftClosedMonoidalCoevaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group119">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalEvaluationForLeftDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalEvaluationForLeftDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalEvaluationForLeftDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftClosedMonoidalEvaluationForLeftDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group120">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalEvaluationForLeftDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalEvaluationForLeftDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalEvaluationForLeftDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{LeftClosedMonoidalEvaluationForLeftDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group121">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftClosedMonoidalEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group122">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalEvaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{LeftClosedMonoidalEvaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group123">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalLambdaElimination" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalLambdaElimination" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalLambdaElimination</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{LeftClosedMonoidalLambdaElimination}(a, b, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group124">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalLambdaIntroduction" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalLambdaIntroduction</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{LeftClosedMonoidalLambdaIntroduction}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group125">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalPostComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalPostComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalPostComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{LeftClosedMonoidalPostComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group126">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalPostComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{LeftClosedMonoidalPostComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group127">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalPreComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalPreComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalPreComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{LeftClosedMonoidalPreComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group128">
  <Oper Arg="C, F" Name="AddLeftClosedMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftClosedMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftClosedMonoidalPreComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{LeftClosedMonoidalPreComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group129">
  <Oper Arg="C, F" Name="AddLeftDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDualOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDualOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{LeftDualOnMorphisms}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group130">
  <Oper Arg="C, F" Name="AddLeftDualOnMorphismsWithGivenLeftDuals" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDualOnMorphismsWithGivenLeftDuals" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDualOnMorphismsWithGivenLeftDuals</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{LeftDualOnMorphismsWithGivenLeftDuals}(s, alpha, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group131">
  <Oper Arg="C, F" Name="AddLeftDualOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftDualOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDualOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftDualOnObjects}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group132">
  <Oper Arg="C, F" Name="AddLeftInternalHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalHomOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalHomOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha, beta ) \mapsto \mathtt{LeftInternalHomOnMorphisms}(alpha, beta)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group133">
  <Oper Arg="C, F" Name="AddLeftInternalHomOnMorphismsWithGivenLeftInternalHoms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalHomOnMorphismsWithGivenLeftInternalHoms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalHomOnMorphismsWithGivenLeftInternalHoms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{LeftInternalHomOnMorphismsWithGivenLeftInternalHoms}(s, alpha, beta, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group134">
  <Oper Arg="C, F" Name="AddLeftInternalHomOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalHomOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalHomOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftInternalHomOnObjects}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group135">
  <Oper Arg="C, F" Name="AddLeftInternalHomToTensorProductAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalHomToTensorProductAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalHomToTensorProductAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g ) \mapsto \mathtt{LeftInternalHomToTensorProductAdjunctMorphism}(b, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group136">
  <Oper Arg="C, F" Name="AddLeftInternalHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalHomToTensorProductAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g, t ) \mapsto \mathtt{LeftInternalHomToTensorProductAdjunctMorphismWithGivenTensorProduct}(b, c, g, t)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group137">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToLeftInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToLeftInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToLeftInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromTensorProductToLeftInternalHom}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group138">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToLeftInternalHomWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToLeftInternalHomWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToLeftInternalHomWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromTensorProductToLeftInternalHomWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group139">
  <Oper Arg="C, F" Name="AddMorphismToLeftBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToLeftBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToLeftBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismToLeftBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group140">
  <Oper Arg="C, F" Name="AddMorphismToLeftBidualWithGivenLeftBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToLeftBidualWithGivenLeftBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToLeftBidualWithGivenLeftBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{MorphismToLeftBidualWithGivenLeftBidual}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group141">
  <Oper Arg="C, F" Name="AddTensorProductLeftDualityCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductLeftDualityCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductLeftDualityCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{TensorProductLeftDualityCompatibilityMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group142">
  <Oper Arg="C, F" Name="AddTensorProductLeftDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductLeftDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductLeftDualityCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{TensorProductLeftDualityCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group143">
  <Oper Arg="C, F" Name="AddTensorProductLeftInternalHomCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductLeftInternalHomCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductLeftInternalHomCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{TensorProductLeftInternalHomCompatibilityMorphism}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group144">
  <Oper Arg="C, F" Name="AddTensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{TensorProductLeftInternalHomCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group145">
  <Oper Arg="C, F" Name="AddTensorProductToLeftInternalHomAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToLeftInternalHomAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToLeftInternalHomAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f ) \mapsto \mathtt{TensorProductToLeftInternalHomAdjunctMorphism}(a, b, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group146">
  <Oper Arg="C, F" Name="AddTensorProductToLeftInternalHomAdjunctMorphismWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToLeftInternalHomAdjunctMorphismWithGivenLeftInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToLeftInternalHomAdjunctMorphismWithGivenLeftInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, f, i ) \mapsto \mathtt{TensorProductToLeftInternalHomAdjunctMorphismWithGivenLeftInternalHom}(a, b, f, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group147">
  <Oper Arg="C, F" Name="AddUniversalPropertyOfLeftDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddUniversalPropertyOfLeftDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfLeftDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfLeftDual}(t, a, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group148">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftCoDualObjectToLeftInternalCoHomFromTensorUnit}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group149">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftInternalCoHomFromTensorUnitToLeftCoDualObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group150">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalCoHomToObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalCoHomToObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalCoHomToObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromLeftInternalCoHomToObject}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group151">
  <Oper Arg="C, F" Name="AddIsomorphismFromLeftInternalCoHomToObjectWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromLeftInternalCoHomToObjectWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromLeftInternalCoHomToObjectWithGivenLeftInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromLeftInternalCoHomToObjectWithGivenLeftInternalCoHom}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group152">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToLeftInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToLeftInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToLeftInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToLeftInternalCoHom}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group153">
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToLeftInternalCoHomWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromObjectToLeftInternalCoHomWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToLeftInternalCoHomWithGivenLeftInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToLeftInternalCoHomWithGivenLeftInternalCoHom}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group154">
  <Oper Arg="C, F" Name="AddLeftCoDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoDualOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoDualOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{LeftCoDualOnMorphisms}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group155">
  <Oper Arg="C, F" Name="AddLeftCoDualOnMorphismsWithGivenLeftCoDuals" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoDualOnMorphismsWithGivenLeftCoDuals" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoDualOnMorphismsWithGivenLeftCoDuals</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{LeftCoDualOnMorphismsWithGivenLeftCoDuals}(s, alpha, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group156">
  <Oper Arg="C, F" Name="AddLeftCoDualOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoDualOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoDualOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftCoDualOnObjects}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group157">
  <Oper Arg="C, F" Name="AddLeftCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoDualityTensorProductCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftCoDualityTensorProductCompatibilityMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group158">
  <Oper Arg="C, F" Name="AddLeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{LeftCoDualityTensorProductCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group159">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalCoevaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalCoevaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftCoclosedMonoidalCoevaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group160">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalCoevaluationMorphismWithGivenSource</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, s ) \mapsto \mathtt{LeftCoclosedMonoidalCoevaluationMorphismWithGivenSource}(a, b, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group161">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalEvaluationForLeftCoDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalEvaluationForLeftCoDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalEvaluationForLeftCoDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftCoclosedMonoidalEvaluationForLeftCoDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group162">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalEvaluationForLeftCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalEvaluationForLeftCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalEvaluationForLeftCoDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{LeftCoclosedMonoidalEvaluationForLeftCoDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group163">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalEvaluationMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalEvaluationMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftCoclosedMonoidalEvaluationMorphism}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group164">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalEvaluationMorphismWithGivenRange</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, r ) \mapsto \mathtt{LeftCoclosedMonoidalEvaluationMorphismWithGivenRange}(a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group165">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalLambdaElimination" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalLambdaElimination" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalLambdaElimination</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{LeftCoclosedMonoidalLambdaElimination}(a, b, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group166">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalLambdaIntroduction" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalLambdaIntroduction</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{LeftCoclosedMonoidalLambdaIntroduction}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group167">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalPostCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalPostCoComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalPostCoComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{LeftCoclosedMonoidalPostCoComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group168">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{LeftCoclosedMonoidalPostCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group169">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalPreCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalPreCoComposeMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalPreCoComposeMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{LeftCoclosedMonoidalPreCoComposeMorphism}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group170">
  <Oper Arg="C, F" Name="AddLeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{LeftCoclosedMonoidalPreCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group171">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha, beta ) \mapsto \mathtt{LeftInternalCoHomOnMorphisms}(alpha, beta)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group172">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomOnMorphismsWithGivenLeftInternalCoHoms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomOnMorphismsWithGivenLeftInternalCoHoms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomOnMorphismsWithGivenLeftInternalCoHoms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{LeftInternalCoHomOnMorphismsWithGivenLeftInternalCoHoms}(s, alpha, beta, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group173">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{LeftInternalCoHomOnObjects}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group174">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomTensorProductCompatibilityMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{LeftInternalCoHomTensorProductCompatibilityMorphism}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group175">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{LeftInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group176">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomToTensorProductAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomToTensorProductAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomToTensorProductAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, f ) \mapsto \mathtt{LeftInternalCoHomToTensorProductAdjunctMorphism}(a, c, f)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group177">
  <Oper Arg="C, F" Name="AddLeftInternalCoHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftInternalCoHomToTensorProductAdjunctMorphismWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftInternalCoHomToTensorProductAdjunctMorphismWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, c, f, t ) \mapsto \mathtt{LeftInternalCoHomToTensorProductAdjunctMorphismWithGivenTensorProduct}(a, c, f, t)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group178">
  <Oper Arg="C, F" Name="AddMorphismFromLeftCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromLeftCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromLeftCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismFromLeftCoBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group179">
  <Oper Arg="C, F" Name="AddMorphismFromLeftCoBidualWithGivenLeftCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromLeftCoBidualWithGivenLeftCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromLeftCoBidualWithGivenLeftCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{MorphismFromLeftCoBidualWithGivenLeftCoBidual}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group180">
  <Oper Arg="C, F" Name="AddMorphismFromLeftInternalCoHomToTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromLeftInternalCoHomToTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromLeftInternalCoHomToTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromLeftInternalCoHomToTensorProduct}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group181">
  <Oper Arg="C, F" Name="AddMorphismFromLeftInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromLeftInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromLeftInternalCoHomToTensorProductWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromLeftInternalCoHomToTensorProductWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group182">
  <Oper Arg="C, F" Name="AddTensorProductToLeftInternalCoHomAdjunctMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToLeftInternalCoHomAdjunctMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToLeftInternalCoHomAdjunctMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g ) \mapsto \mathtt{TensorProductToLeftInternalCoHomAdjunctMorphism}(b, c, g)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group183">
  <Oper Arg="C, F" Name="AddTensorProductToLeftInternalCoHomAdjunctMorphismWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductToLeftInternalCoHomAdjunctMorphismWithGivenLeftInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToLeftInternalCoHomAdjunctMorphismWithGivenLeftInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( b, c, g, i ) \mapsto \mathtt{TensorProductToLeftInternalCoHomAdjunctMorphismWithGivenLeftInternalCoHom}(b, c, g, i)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group184">
  <Oper Arg="C, F" Name="AddUniversalPropertyOfLeftCoDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddUniversalPropertyOfLeftCoDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfLeftCoDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfLeftCoDual}(t, a, alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group185">
  <Oper Arg="C, F" Name="AddAssociatorLeftToRight" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddAssociatorLeftToRight" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorLeftToRight</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{AssociatorLeftToRight}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group186">
  <Oper Arg="C, F" Name="AddAssociatorLeftToRightWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddAssociatorLeftToRightWithGivenTensorProducts" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorLeftToRightWithGivenTensorProducts</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{AssociatorLeftToRightWithGivenTensorProducts}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group187">
  <Oper Arg="C, F" Name="AddAssociatorRightToLeft" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddAssociatorRightToLeft" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorRightToLeft</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b, c ) \mapsto \mathtt{AssociatorRightToLeft}(a, b, c)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group188">
  <Oper Arg="C, F" Name="AddAssociatorRightToLeftWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddAssociatorRightToLeftWithGivenTensorProducts" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorRightToLeftWithGivenTensorProducts</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{AssociatorRightToLeftWithGivenTensorProducts}(s, a, b, c, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group189">
  <Oper Arg="C, F" Name="AddLeftUnitor" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftUnitor" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitor</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftUnitor}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group190">
  <Oper Arg="C, F" Name="AddLeftUnitorInverse" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftUnitorInverse" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorInverse</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{LeftUnitorInverse}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group191">
  <Oper Arg="C, F" Name="AddLeftUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorInverseWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{LeftUnitorInverseWithGivenTensorProduct}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group192">
  <Oper Arg="C, F" Name="AddLeftUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddLeftUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{LeftUnitorWithGivenTensorProduct}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group193">
  <Oper Arg="C, F" Name="AddRightUnitor" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightUnitor" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitor</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{RightUnitor}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group194">
  <Oper Arg="C, F" Name="AddRightUnitorInverse" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightUnitorInverse" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorInverse</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{RightUnitorInverse}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group195">
  <Oper Arg="C, F" Name="AddRightUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorInverseWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{RightUnitorInverseWithGivenTensorProduct}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group196">
  <Oper Arg="C, F" Name="AddRightUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRightUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{RightUnitorWithGivenTensorProduct}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group197">
  <Oper Arg="C, F" Name="AddTensorProductOnMorphisms" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductOnMorphisms" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductOnMorphisms</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha, beta ) \mapsto \mathtt{TensorProductOnMorphisms}(alpha, beta)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group198">
  <Oper Arg="C, F" Name="AddTensorProductOnMorphismsWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductOnMorphismsWithGivenTensorProducts" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductOnMorphismsWithGivenTensorProducts</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{TensorProductOnMorphismsWithGivenTensorProducts}(s, alpha, beta, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group199">
  <Oper Arg="C, F" Name="AddTensorProductOnObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductOnObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductOnObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( arg2, arg3 ) \mapsto \mathtt{TensorProductOnObjects}(arg2, arg3)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group200">
  <Oper Arg="C, F" Name="AddTensorUnit" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorUnit" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorUnit</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: (  ) \mapsto \mathtt{TensorUnit}()</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group201">
  <Oper Arg="C, F" Name="AddCoevaluationForDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoevaluationForDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationForDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{CoevaluationForDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group202">
  <Oper Arg="C, F" Name="AddCoevaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoevaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationForDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoevaluationForDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group203">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToTensorProductWithDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalHomToTensorProductWithDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToTensorProductWithDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromInternalHomToTensorProductWithDualObject}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group204">
  <Oper Arg="C, F" Name="AddIsomorphismFromTensorProductWithDualObjectToInternalHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromTensorProductWithDualObjectToInternalHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromTensorProductWithDualObjectToInternalHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromTensorProductWithDualObjectToInternalHom}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group205">
  <Oper Arg="C, F" Name="AddMorphismFromBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismFromBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group206">
  <Oper Arg="C, F" Name="AddMorphismFromBidualWithGivenBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromBidualWithGivenBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromBidualWithGivenBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, s ) \mapsto \mathtt{MorphismFromBidualWithGivenBidual}(a, s)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group207">
  <Oper Arg="C, F" Name="AddMorphismFromInternalHomToTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromInternalHomToTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalHomToTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromInternalHomToTensorProduct}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group208">
  <Oper Arg="C, F" Name="AddMorphismFromInternalHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromInternalHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalHomToTensorProductWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromInternalHomToTensorProductWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group209">
  <Oper Arg="C, F" Name="AddRankMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddRankMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RankMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{RankMorphism}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group210">
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductInternalHomCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismInverse</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismInverse}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group211">
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group212">
  <Oper Arg="C, F" Name="AddTraceMap" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddTraceMap" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TraceMap</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{TraceMap}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group213">
  <Oper Arg="C, F" Name="AddCoRankMorphism" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoRankMorphism" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoRankMorphism</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{CoRankMorphism}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group214">
  <Oper Arg="C, F" Name="AddCoTraceMap" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoTraceMap" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoTraceMap</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( alpha ) \mapsto \mathtt{CoTraceMap}(alpha)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group215">
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationForCoDual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedCoevaluationForCoDual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationForCoDual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{CoclosedCoevaluationForCoDual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group216">
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddCoclosedCoevaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationForCoDualWithGivenTensorProduct</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoclosedCoevaluationForCoDualWithGivenTensorProduct}(s, a, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group217">
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismInverse</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( list ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismInverse}(list)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group218">
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( source, list, range ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}(source, list, range)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group219">
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToTensorProductWithCoDualObject" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromInternalCoHomToTensorProductWithCoDualObject" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToTensorProductWithCoDualObject</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromInternalCoHomToTensorProductWithCoDualObject}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group220">
  <Oper Arg="C, F" Name="AddIsomorphismFromTensorProductWithCoDualObjectToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddIsomorphismFromTensorProductWithCoDualObjectToInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group221">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToInternalCoHom" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalCoHom</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromTensorProductToInternalCoHom}(a, b)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group222">
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalCoHomWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismFromTensorProductToInternalCoHomWithGivenObjects" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalCoHomWithGivenObjects</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromTensorProductToInternalCoHomWithGivenObjects}(s, a, b, r)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group223">
  <Oper Arg="C, F" Name="AddMorphismToCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a ) \mapsto \mathtt{MorphismToCoBidual}(a)</Math>.
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group224">
  <Oper Arg="C, F" Name="AddMorphismToCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction"/>
  <Oper Arg="C, F, weight" Name="AddMorphismToCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction, IsInt"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToCoBidualWithGivenCoBidual</Code>.
 Optionally, a weight (default: 100) can be specified which should roughly correspond
 to the computational complexity of the function (lower weight = less complex = faster execution).
 <Math>F: ( a, r ) \mapsto \mathtt{MorphismToCoBidualWithGivenCoBidual}(a, r)</Math>.
<P/>
 </Description>
</ManSection>


</Section>


</Chapter>

