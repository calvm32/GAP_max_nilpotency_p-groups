<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples_and_Tests">
<Heading>Examples and Tests</Heading>

<P/>
<Section Label="Chapter_Examples_and_Tests_Section_Test_functions">
<Heading>Test functions</Heading>

<P/>
<ManSection>
  <Func Arg="cat, a, L" Name="AdditiveMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
an object <Math>a</Math>
</Item>
<Item>
a list <Math>L</Math> of objects
</Item>
</List>
 This function checks for every operation
 declared in AdditiveMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b" Name="BraidedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b</Math>
</Item>
</List>
 This function checks for every operation
 declared in BraidedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="ClosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: a \otimes b \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\delta: c \otimes d \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\epsilon: 1 \rightarrow \mathrm{Hom}(a,b)</Math>
</Item>
<Item>
a morphism <Math>\zeta: 1 \rightarrow \mathrm{Hom}(c,d)</Math>
</Item>
</List>
 This function checks for every operation
 declared in ClosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta" Name="ClosedMonoidalCategoriesTestWithGiven" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for some *WithGiven operations
 declared in ClosedMonoidalCategories.gd
 if they are computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="CoclosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: 1 \rightarrow a \otimes b</Math>
</Item>
<Item>
a morphism <Math>\delta: 1 \rightarrow c \otimes d</Math>
</Item>
<Item>
a morphism <Math>\epsilon: \mathrm{coHom}(a,b) \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\zeta: \mathrm{coHom}(c,d) \rightarrow 1</Math>
</Item>
</List>
 This function checks for every operation
 declared in CoclosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="CoclosedMonoidalCategoriesTestWithGiven" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for some *WithGiven operations
 declared in CoclosedMonoidalCategories.gd
 if they are computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="LeftClosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: a \otimes b \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\delta: c \otimes d \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\epsilon: 1 \rightarrow \mathrm{Hom}(a,b)</Math>
</Item>
<Item>
a morphism <Math>\zeta: 1 \rightarrow \mathrm{Hom}(c,d)</Math>
</Item>
</List>
 This function checks for every operation
 declared in LeftClosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="LeftClosedMonoidalCategoriesTestWithGiven" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for some *WithGiven operationS
 declared in LeftClosedMonoidalCategories.gd
 if they are computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="LeftCoclosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: 1 \rightarrow a \otimes b</Math>
</Item>
<Item>
a morphism <Math>\delta: 1 \rightarrow c \otimes d</Math>
</Item>
<Item>
a morphism <Math>\epsilon: \mathrm{coHom}(a,b) \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\zeta: \mathrm{coHom}(c,d) \rightarrow 1</Math>
</Item>
</List>
 This function checks for every operation
 declared in LeftCoclosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="LeftCoclosedMonoidalCategoriesTestWithGiven" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for some *WithGiven operations
 declared in LeftCoclosedMonoidalCategories.gd
 if they are computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b" Name="MonoidalCategoriesTensorProductOnObjectsAndTensorUnitTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b</Math>
</Item>
</List>
 This function checks for every operation
 declared in MonoidalCategoriesTensorProductOnObjectsAndTensorUnit.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, alpha, beta" Name="MonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for every operation
 declared in MonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha" Name="RigidSymmetricClosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
an endomorphism <Math>\alpha: a \rightarrow a</Math>
</Item>
</List>
 This function checks for every object and morphism
 declared in RigidSymmetricClosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha" Name="RigidSymmetricCoclosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
an endomorphism <Math>\alpha: a \rightarrow a</Math>
</Item>
</List>
 This function checks for every object and morphism
 declared in RigidSymmetricCoclosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


</Section>


</Chapter>

