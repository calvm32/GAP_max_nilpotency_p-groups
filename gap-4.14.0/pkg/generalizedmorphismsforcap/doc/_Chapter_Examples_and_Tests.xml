<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples_and_Tests">
<Heading>Examples and Tests</Heading>

<Section Label="Chapter_Examples_and_Tests_Section_Basic_Commands">
<Heading>Basic Commands</Heading>

<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();;
gap> A := VectorSpaceObject( 4, Q );;
gap> B := VectorSpaceObject( 3, Q );;
gap> C := VectorSpaceObject( 2, Q );;
gap> alpha := VectorSpaceMorphism( A, 
> HomalgMatrix( [ [ 1, 1, 1 ], [ 0, 1, 1 ], 
> [ 1, 0, 1 ], [ 1, 1, 0 ] ], 4, 3, Q ), B );;
gap> gamma := VectorSpaceMorphism( C, 
> HomalgMatrix( [ [ -1, 1, -1 ], [ 1, 0, -1 ] ], 2, 3, Q ), B );;
gap> p := ProjectionInFactorOfFiberProduct( [ alpha, gamma ], 1 );;
gap> q := ProjectionInFactorOfFiberProduct( [ alpha, gamma ], 2 );;
gap> PreCompose( AsGeneralizedMorphism( alpha ), GeneralizedInverse( gamma ) );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> gen1 := PreCompose( AsGeneralizedMorphism( alpha ), 
>                        GeneralizedInverse( gamma ) );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> gen2 := PreCompose( GeneralizedInverse( p ), AsGeneralizedMorphism( q ) );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsCongruentForMorphisms( gen1, gen2 );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Intersection_of_Nodal_Curve_and_Cusp">
<Heading>Intersection of Nodal Curve and Cusp</Heading>

 We are going to intersect the nodal curve 
 <Math>f = y^2 - x^2(x+1)</Math>
 and the cusp <Math>g = (x+y)^2 - (y-x)^3</Math>.
 The two curves are arranged in a way such that they intersect
 at <Math>(0,0)</Math> with intersection number as high as possible.
 We are going to compute this intersection number
 using the definition of the intersection number as the
 length of the module <Math>R/(f,g)</Math> localized at <Math>(0,0)</Math>.
 In order to model modules over the localization of <Math>Q[x,y]</Math> at
 <Math>(0,0)</Math>, we use a suitable Serre quotient category.
 1
 2
 1
 1
 true
 We are going to intersect the nodal curve 
 <Math>f = y^2 - x^2(x+1)</Math>
 and the cusp <Math>g = (x+y)^2 - (y-x)^3</Math>.
 The two curves are arranged in a way such that they intersect
 at <Math>(0,0)</Math> with intersection number as high as possible.
 We are going to compute this intersection number
 using the definition of the intersection number as the
 length of the module <Math>R/(f,g)</Math> localized at <Math>(0,0)</Math>.
 In order to model modules over the localization of <Math>Q[x,y]</Math> at
 <Math>(0,0)</Math>, we use a suitable Serre quotient category.
 1
 2
 1
 1
 true
 We are going to intersect the nodal curve 
 <Math>f = y^2 - x^2(x+1)</Math>
 and the cusp <Math>g = (x+y)^2 - (y-x)^3</Math>.
 The two curves are arranged in a way such that they intersect
 at <Math>(0,0)</Math> with intersection number as high as possible.
 We are going to compute this intersection number
 using the definition of the intersection number as the
 length of the module <Math>R/(f,g)</Math> localized at <Math>(0,0)</Math>.
 In order to model modules over the localization of <Math>Q[x,y]</Math> at
 <Math>(0,0)</Math>, we use a suitable Serre quotient category.
 1
 2
 1
 1
 true
</Section>


<Section Label="Chapter_Examples_and_Tests_Section_WrapperCategory">
<Heading>WrapperCategory</Heading>

<Example><![CDATA[
gap> LoadPackage( "LinearAlgebraForCAP" );
true
gap> LoadPackage( "GeneralizedMorphismsForCAP", false );
true
gap> old_generalized_morphism_standard := CAP_INTERNAL!.generalized_morphism_standard;;
gap> SwitchGeneralizedMorphismStandard( "cospan" );
gap> Q := HomalgFieldOfRationals( );
Q
gap> id := HomalgIdentityMatrix( 8, Q );
<An unevaluated 8 x 8 identity matrix over an internal ring>
gap> a := CertainColumns( CertainRows( id, [ 1, 2, 3 ] ), [ 2, 3, 4, 5 ] );
<An unevaluated non-zero 3 x 4 matrix over an internal ring>
gap> b := CertainColumns( CertainRows( id, [ 1, 2, 3, 4 ] ), [ 2, 3, 4, 5, 6 ] );
<An unevaluated non-zero 4 x 5 matrix over an internal ring>
gap> c := CertainColumns( CertainRows( id, [ 1, 2, 3, 4, 5 ] ), [ 3, 4, 5, 6, 7, 8 ] );
<An unevaluated non-zero 5 x 6 matrix over an internal ring>
gap> IsZero( a * b );
false
gap> IsZero( b * c );
false
gap> IsZero( a * b * c );
true
gap> Qmat := MatrixCategory( Q );
Category of matrices over Q
gap> Wrapper := WrapperCategory( Qmat, rec( ) );
WrapperCategory( Category of matrices over Q )
gap> a := a / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> b := b / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> c := c / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> d := CokernelProjection( a );
<An epimorphism in WrapperCategory( Category of matrices over Q )>
gap> e := CokernelColift( a, PreCompose( b, c ) );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> f := KernelEmbedding( e );
<A monomorphism in WrapperCategory( Category of matrices over Q )>
gap> g := KernelEmbedding( c );
<A monomorphism in WrapperCategory( Category of matrices over Q )>
gap> h := KernelLift( c, PreCompose( a, b ) );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> i := CokernelProjection( h );
<An epi morphism in WrapperCategory( Category of matrices over Q )>
gap> ff := AsGeneralizedMorphism( f );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> dd := AsGeneralizedMorphism( d );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> bb := AsGeneralizedMorphism( b );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> gg := AsGeneralizedMorphism( g );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> ii := AsGeneralizedMorphism( i );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> ss := PreCompose( [ ff, PseudoInverse( dd ), bb, PseudoInverse( gg ), ii ] );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> s := HonestRepresentative( ss );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> j := KernelObjectFunctorial( b, d, e );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> k := CokernelObjectFunctorial( h, g, b );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> HK := HomologyObject( j, s );
<An object in WrapperCategory( Category of matrices over Q )>
gap> HC := HomologyObject( s, k );
<An object in WrapperCategory( Category of matrices over Q )>
gap> SwitchGeneralizedMorphismStandard( old_generalized_morphism_standard );
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Sweep">
<Heading>Sweep</Heading>

 <Math>\href{https://terrytao.wordpress.com/2015/10/07/sweeping-a-matrix-rotates-its-graph/}{\textrm{Geometric interpretation of sweeping a matrix by Terence Tao.}}</Math>
<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();;
gap> V := VectorSpaceObject( 3, Q );;
gap> mat := HomalgMatrix( [ [ 9, 8, 7 ], [ 6, 5, 4 ], [ 3, 2, 1 ] ], 3, 3, Q );;
gap> alpha := VectorSpaceMorphism( V, mat, V );;
gap> graph := FiberProductEmbeddingInDirectSum( 
>             [ alpha, IdentityMorphism( V ) ] );;
gap> Display( graph );
[ [     1,    -2,     1,     0,     0,     0 ],
  [  -4/3,   7/3,     0,     2,     1,     0 ],
  [   5/3,  -8/3,     0,    -1,     0,     1 ] ]

A morphism in Category of matrices over Q
gap> D := DirectSum( V, V );;
gap> rotmat := HomalgMatrix( [ [ 0, 0, 0, -1, 0, 0 ],
>                              [ 0, 1, 0, 0, 0, 0 ],
>                              [ 0, 0, 1, 0, 0, 0 ],
>                              [ 1, 0, 0, 0, 0, 0 ],
>                              [ 0, 0, 0, 0, 1, 0 ],
>                              [ 0, 0, 0, 0, 0, 1 ] ],
>                              6, 6, Q );;
gap> rot := VectorSpaceMorphism( D, rotmat, D );;
gap> p := PreCompose( graph, rot );;
gap> Display( p );
[ [     0,    -2,     1,    -1,     0,     0 ],
  [     2,   7/3,     0,   4/3,     1,     0 ],
  [    -1,  -8/3,     0,  -5/3,     0,     1 ] ]

A morphism in Category of matrices over Q
gap> pi1 := ProjectionInFactorOfDirectSum( [ V, V ], 1 );;
gap> pi2 := ProjectionInFactorOfDirectSum( [ V, V ], 2 );;
gap> reversed_arrow := PreCompose( p, pi1 );;
gap> arrow := PreCompose( p, pi2 );;
gap> g := GeneralizedMorphismBySpan( reversed_arrow, arrow );;
gap> IsHonest( g );
true
gap> sweep_1_alpha := HonestRepresentative( g );;
gap> Display( sweep_1_alpha );
[ [  -1/9,   8/9,   7/9 ],
  [   2/3,  -1/3,  -2/3 ],
  [   1/3,  -2/3,  -4/3 ] ]

A morphism in Category of matrices over Q
gap> Display( alpha );
[ [  9,  8,  7 ],
  [  6,  5,  4 ],
  [  3,  2,  1 ] ]

A morphism in Category of matrices over Q
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Generalized_Morphisms_Category">
<Heading>Generalized Morphisms Category</Heading>

<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> C := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> B_1 := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> C_1 := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> c1_source_aid := VectorSpaceMorphism( B_1, [ [ 1, 0 ] ], B );
<A morphism in Category of matrices over Q>
gap> SetIsSubobject( c1_source_aid, true );
gap> c1_range_aid := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 1 ], [ 0, 0 ] ], C_1 );
<A morphism in Category of matrices over Q>
gap> SetIsFactorobject( c1_range_aid, true );
gap> c1_associated := VectorSpaceMorphism( B_1, [ [ 1, 1 ] ], C_1 );
<A morphism in Category of matrices over Q>
gap> c1 := GeneralizedMorphism( c1_source_aid, c1_associated, c1_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> B_2 := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> C_2 := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> c2_source_aid := VectorSpaceMorphism( B_2, [ [ 2, 0 ] ], B );
<A morphism in Category of matrices over Q>
gap> SetIsSubobject( c2_source_aid, true );
gap> c2_range_aid := VectorSpaceMorphism( C, [ [ 3, 0 ], [ 0, 3 ], [ 0, 0 ] ], C_2 );
<A morphism in Category of matrices over Q>
gap> SetIsFactorobject( c2_range_aid, true );
gap> c2_associated := VectorSpaceMorphism( B_2, [ [ 6, 6 ] ], C_2 );
<A morphism in Category of matrices over Q>
gap> c2 := GeneralizedMorphism( c2_source_aid, c2_associated, c2_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsCongruentForMorphisms( c1, c2 );
true
gap> IsCongruentForMorphisms( c1, c1 );
true
gap> c3_associated := VectorSpaceMorphism( B_1, [ [ 2, 2 ] ], C_1 );
<A morphism in Category of matrices over Q>
gap> c3 := GeneralizedMorphism( c1_source_aid, c3_associated, c1_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsCongruentForMorphisms( c1, c3 );
false
gap> IsCongruentForMorphisms( c2, c3 );
false
gap> c1 + c2;
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> Arrow( c1 + c2 );
<A morphism in Category of matrices over Q>
]]></Example>


 First composition test:
<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> C := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> phi_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 2, 0 ] ], C );
<A morphism in Category of matrices over Q>
gap> phi_tilde_source_aid := VectorSpaceMorphism( A, [ [ 1, 2 ] ], B );
<A morphism in Category of matrices over Q>
gap> phi_tilde := GeneralizedMorphismWithSourceAid( phi_tilde_source_aid, phi_tilde_associated );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> psi_tilde_associated := IdentityMorphism( B );
<An identity morphism in Category of matrices over Q>
gap> psi_tilde_source_aid := VectorSpaceMorphism( B, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], C );
<A morphism in Category of matrices over Q>
gap> psi_tilde := GeneralizedMorphismWithSourceAid( psi_tilde_source_aid, psi_tilde_associated );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> composition := PreCompose( phi_tilde, psi_tilde );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> Arrow( composition );
<A morphism in Category of matrices over Q>
gap> SourceAid( composition );
<A morphism in Category of matrices over Q>
gap> RangeAid( composition );
<An identity morphism in Category of matrices over Q>
]]></Example>


 Second composition test
<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> C := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> phi2_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 5 ] ], B );
<A morphism in Category of matrices over Q>
gap> phi2_tilde_range_aid := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], B );
<A morphism in Category of matrices over Q>
gap> phi2_tilde := GeneralizedMorphismWithRangeAid( phi2_tilde_associated, phi2_tilde_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> psi2_tilde_associated := VectorSpaceMorphism( C, [ [ 1 ], [ 3 ], [ 4 ] ], A );
<A morphism in Category of matrices over Q>
gap> psi2_tilde_range_aid := VectorSpaceMorphism( B, [ [ 1 ], [ 1 ] ], A );
<A morphism in Category of matrices over Q>
gap> psi2_tilde := GeneralizedMorphismWithRangeAid( psi2_tilde_associated, psi2_tilde_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> composition2 := PreCompose( phi2_tilde, psi2_tilde );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> Arrow( composition2 );
<A morphism in Category of matrices over Q>
gap> RangeAid( composition2 );
<A morphism in Category of matrices over Q>
gap> SourceAid( composition2 );
<An identity morphism in Category of matrices over Q>
]]></Example>


 Third composition test
<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> A := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Asub := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> B := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Bfac := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> Bsub := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> C := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Cfac := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> Asub_into_A := VectorSpaceMorphism( Asub, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], A );
<A morphism in Category of matrices over Q>
gap> Asub_to_Bfac := VectorSpaceMorphism( Asub, [ [ 1 ], [ 1 ] ], Bfac );
<A morphism in Category of matrices over Q>
gap> B_onto_Bfac := VectorSpaceMorphism( B, [ [ 1 ], [ 1 ], [ 1 ] ], Bfac );
<A morphism in Category of matrices over Q>
gap> Bsub_into_B := VectorSpaceMorphism( Bsub, [ [ 2, 2, 0 ], [ 0, 2, 2 ] ], B );
<A morphism in Category of matrices over Q>
gap> Bsub_to_Cfac := VectorSpaceMorphism( Bsub, [ [ 3 ], [ 0 ] ], Cfac );
<A morphism in Category of matrices over Q>
gap> C_onto_Cfac := VectorSpaceMorphism( C, [ [ 1 ], [ 2 ], [ 3 ] ], Cfac );
<A morphism in Category of matrices over Q>
gap> generalized_morphism1 := GeneralizedMorphism( Asub_into_A, Asub_to_Bfac, B_onto_Bfac );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> generalized_morphism2 := GeneralizedMorphism( Bsub_into_B, Bsub_to_Cfac, C_onto_Cfac );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsWellDefined( generalized_morphism1 );
true
gap> IsWellDefined( generalized_morphism2 );
true
gap> p := PreCompose( generalized_morphism1, generalized_morphism2 );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> SourceAid( p );
<A morphism in Category of matrices over Q>
gap> Arrow( p );
<A morphism in Category of matrices over Q>
gap> RangeAid( p );
<A morphism in Category of matrices over Q>
gap> A := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Asub := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> B := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Bfac := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> Bsub := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> C := VectorSpaceObject( 3, Q );
<A vector space object over Q of dimension 3>
gap> Cfac := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> Bsub_to_Cfac := VectorSpaceMorphism( Bsub, [ [ 3, 3 ], [ 0, 0 ] ], Cfac );
<A morphism in Category of matrices over Q>
gap> C_onto_Cfac := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 2 ], [ 3, 3 ] ], Cfac );
<A morphism in Category of matrices over Q>
gap> generalized_morphism1 := GeneralizedMorphism( Asub_into_A, Asub_to_Bfac, B_onto_Bfac );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> generalized_morphism2 := GeneralizedMorphism( Bsub_into_B, Bsub_to_Cfac, C_onto_Cfac );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsWellDefined( generalized_morphism1 );
true
gap> IsWellDefined( generalized_morphism2 );
true
gap> p := PreCompose( generalized_morphism1, generalized_morphism2 );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> SourceAid( p );
<A morphism in Category of matrices over Q>
gap> Arrow( p );
<A morphism in Category of matrices over Q>
gap> RangeAid( p );
<A morphism in Category of matrices over Q>
]]></Example>


 Honest representative test
<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> phi_tilde_source_aid := VectorSpaceMorphism( A, [ [ 2 ] ], A );
<A morphism in Category of matrices over Q>
gap> phi_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 1 ] ], B );
<A morphism in Category of matrices over Q>
gap> phi_tilde_range_aid := VectorSpaceMorphism( B, [ [ 1, 2 ], [ 3, 4 ] ], B );
<A morphism in Category of matrices over Q>
gap> phi_tilde := GeneralizedMorphism( phi_tilde_source_aid, phi_tilde_associated, phi_tilde_range_aid );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> HonestRepresentative( phi_tilde );
<A morphism in Category of matrices over Q>
gap> IsWellDefined( phi_tilde );
true
gap> IsWellDefined( psi_tilde );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_IsWellDefined">
<Heading>IsWellDefined</Heading>

<Example><![CDATA[
gap> Q := HomalgFieldOfRationals();
Q
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> alpha := VectorSpaceMorphism( A, [ [ 1, 2 ] ], B );
<A morphism in Category of matrices over Q>
gap> g := GeneralizedMorphism( alpha, alpha, alpha );
<A morphism in Generalized morphism category of Category of matrices over Q>
gap> IsWellDefined( alpha );
true
gap> IsWellDefined( g );
true
gap> IsEqualForObjects( A, B );
false
]]></Example>


</Section>


</Chapter>

